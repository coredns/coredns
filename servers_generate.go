//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"go/format"
	"log"
	"os"
	"strings"
)

type server struct {
	scheme      string
	port        string
	imprt       string
	creatorFunc string
}

func main() {
	ms := make(map[string]server, 0)
	file, err := os.Open(serverFile)
	if err != nil {
		log.Fatalf("Failed to open %s: %q", serverFile, err)
	}

	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "#") {
			continue
		}

		items := strings.Split(line, ":")
		if len(items) != 3 {
			// ignore empty lines
			continue
		}

		// dns:53:dnsserver:NewServer
		s := server{scheme: items[0], port: items[1], creatorFunc: items[2]}
		if _, ok := ms[s.scheme]; ok {
			log.Fatalf("Duplicate entry %q", s.scheme)
		}

		in := strings.LastIndexByte(s.creatorFunc, '.')
		if in > -1 && in < len(s.creatorFunc) {
			s.imprt = s.creatorFunc[0:in]
			s.creatorFunc = s.creatorFunc[in+1:]
		}

		ms[s.scheme] = s
	}
	genConsts("plugin/pkg/transport/ztransport.go", "transport", ms)
	genServers("core/dnsserver/zservers.go", "dnsserver", ms)
}

func genConsts(file, pack string, ms map[string]server) {

	var schemes, ports string
	for _, s := range ms {
		upperScheme := strings.ToUpper(s.scheme)
		schemes += upperScheme + ` = "` + s.scheme + `"` + "\n"
		ports += upperScheme + `Port = "` + s.port + `"` + "\n"
	}

	outs := header + "package " + pack + "\n\n"
	outs += `
// These transports are supported by CoreDNS.
const (
` + schemes + ")\n"

	outs += `
	// Port numbers for the various transports.
const (
	// Port is the default port for DNS
	Port = "53"

` + ports + ")\n"

	if err := formatAndWrite(file, outs); err != nil {
		log.Fatalf("Failed to format and write: %q", err)
	}
}

func genServers(file, pack string, ms map[string]server) {

	outs := header + "package " + pack + "\n\n"
	outs += `
// Servers are registered in the order they are specified in the server.cfg
//
import (
	"github.com/coredns/caddy"
	"github.com/coredns/coredns/plugin/pkg/transport"
`

	for _, s := range ms {
		if len(s.imprt) > 0 {
			outs += ` "` + s.imprt + `"` + "\n"
		}
	}
	outs += ")\n"

	outs += `
func init() {
`
	for _, s := range ms {
		upperScheme := "transport." + strings.ToUpper(s.scheme)
		upperSchemePort := upperScheme + "Port"
		outs += `
		RegisterTransportServer(` + upperScheme + `, ` + upperSchemePort + `, func(addr string, group []*Config) (caddy.Server, error) {
			return ` + s.creatorFunc + `(addr, group)
		})
`
	}

	outs += "}\n"
	if err := formatAndWrite(file, outs); err != nil {
		log.Fatalf("Failed to format and write: %q", err)
	}
}

func formatAndWrite(file string, data string) error {
	res, err := format.Source([]byte(data))
	if err != nil {
		return err
	}

	if err = os.WriteFile(file, res, 0644); err != nil {
		return err
	}
	return nil
}

const (
	serverPath   = "github.com/coredns/coredns/core/dnsserver/"
	serverFile   = "server.cfg"
	serverFSPath = "core/dnsserver/" // Where the servers are located on the file system
	header       = "// generated by servers_generate.go; DO NOT EDIT\n\n"
)
