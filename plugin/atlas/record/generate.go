//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"text/template"
)

var packageHdr = `
// Code generated by coredns Atlas plugin; DO NOT EDIT.

package record

import (
	"encoding/json"

	"github.com/miekg/dns"
)
`

var marshalFunc = template.Must(template.New("marshalFunc").Parse(`
{{range .}}
// Marshal {{.Name}} RR and return json string and error if any
func (rec {{.Name}}) Marshal() (s string, e error) { 
	var m []byte
	if m, e = json.Marshal(rec); e != nil {
		return
	}
	return string(m), nil
}

func New{{.Name}}(rec *dns.{{.Name}}) {{.Name}} {
	return {{.Name}}{
	{{range .Fields -}}
	{{if not .IsArray -}}
	{{.Name}}: rec.{{.Name}},
	{{- end}}
	{{- end}}
	}
}
{{end}}
`))

type Field struct {
	Name    string
	Type    string
	IsArray bool
}

type OutputType struct {
	Name   string
	Fields []Field
}

func main() {

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, "rr_types.go", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	outTypes := make([]OutputType, 0)

	for _, node := range node.Decls {
		switch node.(type) {

		case *ast.GenDecl:
			genDecl := node.(*ast.GenDecl)
			for _, spec := range genDecl.Specs {
				switch spec.(type) {
				case *ast.TypeSpec:
					typeSpec := spec.(*ast.TypeSpec)

					t := OutputType{Name: typeSpec.Name.Name}

					switch typeSpec.Type.(type) {
					case *ast.StructType:
						structType := typeSpec.Type.(*ast.StructType)
						for _, field := range structType.Fields.List {
							// TODO(jproxx): switch all types
							// fmt.Printf("%v => %v\n", field, field.Type)
							i, ok := field.Type.(*ast.Ident)
							if ok {
								fieldType := i.Name
								for _, name := range field.Names {
									//fmt.Printf("\tField: name=%s type=%s\n", name.Name, fieldType)
									f := Field{Name: name.Name, Type: fieldType, IsArray: false}
									t.Fields = append(t.Fields, f)
								}
							}
							a, ok := field.Type.(*ast.ArrayType)
							if ok {
								i, identOk := a.Elt.(*ast.Ident)
								if identOk {
									//fmt.Printf("ArrayType: %+v => %v\n", a, i.Name)
									f := Field{Type: i.Name, IsArray: true}
									t.Fields = append(t.Fields, f)
								}
							}

						}
					}
					outTypes = append(outTypes, t)
				}

			}
		}
	}

	b := &bytes.Buffer{}
	b.WriteString(packageHdr)

	if err := marshalFunc.Execute(b, outTypes); err != nil {
		log.Panic(err)
	}

	file, _ := os.Create("rr_types_generated.go")
	defer file.Close()

	formatted, err := format.Source(b.Bytes())
	if err != nil {
		log.Panic(err)
	}

	if _, err := file.Write(formatted); err != nil {
		log.Panic(err)
	}
}
