// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/coredns/coredns/plugin/atlas/ent/dnszone"
	"github.com/rs/xid"
)

// DnsZone is the model entity for the DnsZone schema.
type DnsZone struct {
	config `json:"-"`
	// ID of the ent.
	// record identifier
	ID xid.ID `json:"id,omitempty"`
	// record creation date
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// record update date
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	// dns zone name must be end with a dot '.' ex: 'example.com.'
	Name string `json:"name,omitempty"`
	// resource record type
	Rrtype uint16 `json:"rrtype,omitempty"`
	// class
	Class uint16 `json:"class,omitempty"`
	// Time-to-live
	TTL uint32 `json:"ttl,omitempty"`
	// primary master name server for this zone
	Ns string `json:"ns,omitempty"`
	// email address of the administrator responsible for this zone. (As usual, the email address is encoded as a name. The part of the email address before the @ becomes the first label of the name; the domain name after the @ becomes the rest of the name. In zone-file format, dots in labels are escaped with backslashes; thus the email address john.doe@example.com would be represented in a zone file as john.doe.example.com.)
	Mbox string `json:"mbox,omitempty"`
	// serial
	Serial uint32 `json:"serial,omitempty"`
	// number of seconds after which secondary name servers should query the master for the SOA record, to detect zone changes. Recommendation for small and stable zones:[4] 86400 seconds (24 hours).
	Refresh uint32 `json:"refresh,omitempty"`
	// Number of seconds after which secondary name servers should retry to request the serial number from the master if the master does not respond. It must be less than Refresh. Recommendation for small and stable zones: 7200 seconds (2 hours).
	Retry uint32 `json:"retry,omitempty"`
	// Number of seconds after which secondary name servers should stop answering request for this zone if the master does not respond. This value must be bigger than the sum of Refresh and Retry. Recommendation for small and stable zones: 3600000 seconds (1000 hours).
	Expire uint32 `json:"expire,omitempty"`
	// The unsigned 32 bit minimum TTL field that should be exported with any RR from this zone.
	Minttl uint32 `json:"minttl,omitempty"`
	// only activated zones will be served
	Activated bool `json:"activated,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the DnsZoneQuery when eager-loading is set.
	Edges DnsZoneEdges `json:"edges"`
}

// DnsZoneEdges holds the relations/edges for other nodes in the graph.
type DnsZoneEdges struct {
	// Records holds the value of the records edge.
	Records []*DnsRR `json:"records,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// RecordsOrErr returns the Records value or an error if the edge
// was not loaded in eager-loading.
func (e DnsZoneEdges) RecordsOrErr() ([]*DnsRR, error) {
	if e.loadedTypes[0] {
		return e.Records, nil
	}
	return nil, &NotLoadedError{edge: "records"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*DnsZone) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case dnszone.FieldActivated:
			values[i] = new(sql.NullBool)
		case dnszone.FieldRrtype, dnszone.FieldClass, dnszone.FieldTTL, dnszone.FieldSerial, dnszone.FieldRefresh, dnszone.FieldRetry, dnszone.FieldExpire, dnszone.FieldMinttl:
			values[i] = new(sql.NullInt64)
		case dnszone.FieldName, dnszone.FieldNs, dnszone.FieldMbox:
			values[i] = new(sql.NullString)
		case dnszone.FieldCreatedAt, dnszone.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		case dnszone.FieldID:
			values[i] = new(xid.ID)
		default:
			return nil, fmt.Errorf("unexpected column %q for type DnsZone", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the DnsZone fields.
func (dz *DnsZone) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case dnszone.FieldID:
			if value, ok := values[i].(*xid.ID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				dz.ID = *value
			}
		case dnszone.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				dz.CreatedAt = new(time.Time)
				*dz.CreatedAt = value.Time
			}
		case dnszone.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				dz.UpdatedAt = new(time.Time)
				*dz.UpdatedAt = value.Time
			}
		case dnszone.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				dz.Name = value.String
			}
		case dnszone.FieldRrtype:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field rrtype", values[i])
			} else if value.Valid {
				dz.Rrtype = uint16(value.Int64)
			}
		case dnszone.FieldClass:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field class", values[i])
			} else if value.Valid {
				dz.Class = uint16(value.Int64)
			}
		case dnszone.FieldTTL:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field ttl", values[i])
			} else if value.Valid {
				dz.TTL = uint32(value.Int64)
			}
		case dnszone.FieldNs:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field ns", values[i])
			} else if value.Valid {
				dz.Ns = value.String
			}
		case dnszone.FieldMbox:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mbox", values[i])
			} else if value.Valid {
				dz.Mbox = value.String
			}
		case dnszone.FieldSerial:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field serial", values[i])
			} else if value.Valid {
				dz.Serial = uint32(value.Int64)
			}
		case dnszone.FieldRefresh:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field refresh", values[i])
			} else if value.Valid {
				dz.Refresh = uint32(value.Int64)
			}
		case dnszone.FieldRetry:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field retry", values[i])
			} else if value.Valid {
				dz.Retry = uint32(value.Int64)
			}
		case dnszone.FieldExpire:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field expire", values[i])
			} else if value.Valid {
				dz.Expire = uint32(value.Int64)
			}
		case dnszone.FieldMinttl:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field minttl", values[i])
			} else if value.Valid {
				dz.Minttl = uint32(value.Int64)
			}
		case dnszone.FieldActivated:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field activated", values[i])
			} else if value.Valid {
				dz.Activated = value.Bool
			}
		}
	}
	return nil
}

// QueryRecords queries the "records" edge of the DnsZone entity.
func (dz *DnsZone) QueryRecords() *DnsRRQuery {
	return NewDnsZoneClient(dz.config).QueryRecords(dz)
}

// Update returns a builder for updating this DnsZone.
// Note that you need to call DnsZone.Unwrap() before calling this method if this DnsZone
// was returned from a transaction, and the transaction was committed or rolled back.
func (dz *DnsZone) Update() *DnsZoneUpdateOne {
	return NewDnsZoneClient(dz.config).UpdateOne(dz)
}

// Unwrap unwraps the DnsZone entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (dz *DnsZone) Unwrap() *DnsZone {
	_tx, ok := dz.config.driver.(*txDriver)
	if !ok {
		panic("ent: DnsZone is not a transactional entity")
	}
	dz.config.driver = _tx.drv
	return dz
}

// String implements the fmt.Stringer.
func (dz *DnsZone) String() string {
	var builder strings.Builder
	builder.WriteString("DnsZone(")
	builder.WriteString(fmt.Sprintf("id=%v, ", dz.ID))
	if v := dz.CreatedAt; v != nil {
		builder.WriteString("created_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := dz.UpdatedAt; v != nil {
		builder.WriteString("updated_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(dz.Name)
	builder.WriteString(", ")
	builder.WriteString("rrtype=")
	builder.WriteString(fmt.Sprintf("%v", dz.Rrtype))
	builder.WriteString(", ")
	builder.WriteString("class=")
	builder.WriteString(fmt.Sprintf("%v", dz.Class))
	builder.WriteString(", ")
	builder.WriteString("ttl=")
	builder.WriteString(fmt.Sprintf("%v", dz.TTL))
	builder.WriteString(", ")
	builder.WriteString("ns=")
	builder.WriteString(dz.Ns)
	builder.WriteString(", ")
	builder.WriteString("mbox=")
	builder.WriteString(dz.Mbox)
	builder.WriteString(", ")
	builder.WriteString("serial=")
	builder.WriteString(fmt.Sprintf("%v", dz.Serial))
	builder.WriteString(", ")
	builder.WriteString("refresh=")
	builder.WriteString(fmt.Sprintf("%v", dz.Refresh))
	builder.WriteString(", ")
	builder.WriteString("retry=")
	builder.WriteString(fmt.Sprintf("%v", dz.Retry))
	builder.WriteString(", ")
	builder.WriteString("expire=")
	builder.WriteString(fmt.Sprintf("%v", dz.Expire))
	builder.WriteString(", ")
	builder.WriteString("minttl=")
	builder.WriteString(fmt.Sprintf("%v", dz.Minttl))
	builder.WriteString(", ")
	builder.WriteString("activated=")
	builder.WriteString(fmt.Sprintf("%v", dz.Activated))
	builder.WriteByte(')')
	return builder.String()
}

// DnsZones is a parsable slice of DnsZone.
type DnsZones []*DnsZone
